﻿/**
* License info for polynomial(...), gaussianElimination(...), round(...), determinationCoefficient(...)
* Function taken from source code of Regression.JS
*
* Regression.JS - Regression functions for javascript
* http://tom-alexander.github.com/regression-js/
*
* copyright(c) 2013 Tom Alexander
* Licensed under the MIT license.
*
* Least-squares regression functions for JavaScript
**/

function round(t, n) { const r = 10 ** n; return Math.round(t * r) / r } function polynomial(t, n) { const r = [], o = []; let a = 0, h = 0; const e = t.length, u = n.order + 1; for (let n = 0; n < u; n++) { for (let r = 0; r < e; r++)null !== t[r][1] && (a += t[r][0] ** n * t[r][1]); r.push(a), a = 0; const s = []; for (let r = 0; r < u; r++) { for (let o = 0; o < e; o++)null !== t[o][1] && (h += t[o][0] ** (n + r)); s.push(h), h = 0 } o.push(s) } o.push(r); const s = gaussianElimination(o, u).map(t => round(t, 2)), l = t => [round(t, 2), round(s.reduce((n, r, o) => n + r * t ** o, 0), 2)], i = t.map(t => l(t[0])); let f = "y = "; for (let t = s.length - 1; t >= 0; t--)f += t > 1 ? `${s[t]}x^${t} + ` : 1 === t ? `${s[t]}x + ` : s[t]; return { string: f, points: i, predict: l, equation: [...s].reverse(), r2: round(determinationCoefficient(t, i), 2) } } function gaussianElimination(t, n) { const r = t, o = t.length - 1, a = [n]; for (let t = 0; t < o; t++) { let n = t; for (let a = t + 1; a < o; a++)Math.abs(r[t][a]) > Math.abs(r[t][n]) && (n = a); for (let a = t; a < o + 1; a++) { const o = r[a][t]; r[a][t] = r[a][n], r[a][n] = o } for (let n = t + 1; n < o; n++)for (let a = o; a >= t; a--)r[a][n] -= r[a][t] * r[t][n] / r[t][t] } for (let t = o - 1; t >= 0; t--) { let n = 0; for (let h = t + 1; h < o; h++)n += r[h][t] * a[h]; a[t] = (r[o][t] - n) / r[t][t] } return a } function determinationCoefficient(t, n) { const r = [], o = []; t.forEach((t, a) => { null !== t[1] && (o.push(t), r.push(n[a])) }); const a = o.reduce((t, n) => t + n[1], 0) / o.length, h = o.reduce((t, n) => { const r = n[1] - a; return t + r * r }, 0); return 1 - o.reduce((t, n, o) => { const a = r[o], h = n[1] - a[1]; return t + h * h }, 0) / h } function areaOfRegion(t, n) { const r = n; for (var o = t, a = [], h = [], e = 0; e <= o.length - 1; e++)a.push(o[e][0]); for (e = 0; e <= o.length - 1; e++)h.push(o[e][1]); var u = Math.min(...a), s = Math.max(...a), l = Math.min(...h), i = Math.max(...h), f = [], p = [], M = 0, c = !0, m = 0; for (e = 0; !0 === c; e++)a[e] !== Math.max(...a) && a[e] !== Math.min(...a) && (m = e, c = !1); var g = m, d = !0, v = !0; for (e = 0; e < a.length; e++)g > a.length - 1 && (g = 0), a[g] === Math.max(...a) && (!0 === d ? (f.push(o[g]), p.push(o[g]), d = !1, 0 === M ? M = 1 : 1 === M && (M = 0)) : 0 === M ? (f.pop(o[g - 1]), f.push(o[g])) : 1 === M && (p.pop(o[g - 1]), p.push(o[g]))), a[g] === Math.min(...a) && (!0 === v ? (f.push(o[g]), p.push(o[g]), v = !1, 0 === M ? M = 1 : 1 === M && (M = 0)) : 0 === M ? (f.pop(o[g - 1]), f.push(o[g])) : 1 === M && (p.pop(o[g - 1]), p.push(o[g]))), a[g] !== Math.min(...a) && a[g] !== Math.max(...a) && (0 === M ? f.push(o[g]) : 1 === M && p.push(o[g])), g++; function x(t, n) { for (var r = 0, o = 0; o <= n.length - 1; o++)r += n[n.length - 1 - o] * Math.pow(t, o); return r } var b = 0, q = 0, w = 0, y = [], E = [], O = [], $ = []; for (e = 0; e <= f.length - 1; e++)O.push(f[e][0]); for (e = 0; e <= f.length - 1; e++)$.push(f[e][1]); var C = [], R = []; for (e = 0; e <= p.length - 1; e++)C.push(p[e][0]); for (e = 0; e <= p.length - 1; e++)R.push(p[e][1]); for (e = 1; Math.min(...y) >= .1 && e <= 121; e++) { q = 0, q = 1, b = polynomial(f, { order: e }), polynomial(p, { order: e }); for (var j = 0; j <= O.length - 1; j++)q += Math.pow($[j] - x(O[j], b.equation), 2); y.push(Math.sqrt(q / f.length)); for (j = 0; j <= C.length - 1; j++)w += Math.pow(R[j] - x(C[j], b.equation), 2); E.push(Math.sqrt(w / p.length)) } var k = polynomial(f, { order: y.indexOf(Math.min(...y)) + 1 }), z = polynomial(p, { order: E.indexOf(Math.min(...E)) + 1 }), A = k.equation, B = z.equation, D = (s - u) * (i - l); function F(t, n) { for (var r = 0, o = 0; o <= n.length - 1; o++)r += n[n.length - 1 - o] * Math.pow(t, o); return r > l && r < i ? r : r <= l ? l : r >= i ? i : void 0 } function G(t, n, r) { var o = F(t + r, n), a = F(t, n); return (o - a) * r / 2 + a * r } function H(t, n, r) { var o = F(t + r, n), a = F(t, n); return Math.sqrt(Math.pow(o - a, 2) + Math.pow(r, 2)) } function I(t, n, r) { for (var o = u, a = 0, e = 0, f = 0, p = 0, M = 0, c = [], m = [], g = 0; g <= n.length - 1; g++)c.push(n[g][0]); for (g = 0; g <= n.length - 1; g++)m.push(n[g][1]); if (Math.min(...m) === Math.min(...h)) for (; o <= s - r;)a += Math.abs((l - F(o, t)) * r), f += Math.abs((l - F(o + r, t)) * r), e += Math.abs((l - F(o + .5 * r, t)) * r), M += H(o, t, r), p += Math.abs(G(o, t, r) - l * r), o += r; if (Math.max(...m) === Math.max(...h)) for (; o <= s - r;)a += Math.abs((i - F(o + r, t)) * r), f += Math.abs((i - F(o, t)) * r), e += Math.abs((i - F(o + .5 * r, t)) * r), M += H(o, t, r), p += Math.abs(i * r - G(o, t, r)), o += r; return [a, e, f, p, M] } var J = I(A, f, r), K = I(B, p, r); return [D - (J[0] + K[0]), D - (J[1] + K[1]), D - (J[2] + K[2]), D - (J[3] + K[3]), J[4] + K[4]] }